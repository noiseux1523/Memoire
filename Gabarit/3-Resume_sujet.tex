% Résumé du mémoire.
%
%   Le résumé est un bref exposé du sujet traité, des objectifs visés,
% des hypothèses émises, des méthodes expérimentales utilisées et de
% l'analyse des résultats obtenus. On y présente également les
% principales conclusions de la recherche ainsi que ses applications
% éventuelles. En général, un résumé ne dépasse pas quatre pages.
%
%   Le résumé doit donner une idée exacte du contenu du mémoire ou de la thèse. Ce ne
% peut pas être une simple énumération des parties du document, car il
% doit faire ressortir l'originalité de la recherche, son aspect
% créatif et sa contribution au développement de la technologie ou à
% l'avancement des connaissances en génie et en sciences appliquées.
% Un résumé ne doit jamais comporter de références ou de figures.

%TOTAL = 4 pages

\chapter*{RÉSUMÉ}\thispagestyle{headings}
\addcontentsline{toc}{compteur}{RÉSUMÉ}

\setlength{\parindent}{5ex} Les \ac{TD} sont des solutions temporaires et peu optimales introduites dans le code source d'un logiciel informatique pour corriger un probl\`{e}me rapidement au d\'{e}triment de la qualit\'{e} logiciel. Cette pratique est r\'{e}pendu pour diverses raisons: rapidit\'{e} d'impl\'{e}mentation, conception initiale des composantes, connaissances faibles du projet, inexp\'{e}rience du d\'{e}veloppeur ou pression face aux dates limites. Les \ac{TD} peuvent s'av\'{e}rer utiles \`{a} court terme, mais excessivement dommageables pour un logiciel et accaparantes au niveau du temps perdu. En effet, le temps requis pour corriger des probl\`{e}me et concevoir du code de qualit\'{e} n'est souvent pas compatible avec le cycle de d\'{e}veloppement d'un projet. C'est pourquoi le sujet des \ac{TD} a \'{e}t\'{e} analys\'{e} dans de nombreuses \'{e}tudes d\'{e}j\`{a}, plus sp\'{e}cifiquement dans l'optique de les d\'{e}tecter et les identifier. \par

Une approche populaire et r\'{e}cente est d'identifier les \ac{TD} qui sont consciemment admises dans le code. La particularit\'{e}s de ces dettes, en comparaison aux \ac{TD}, est qu'elles sont explicitement document\'{e}es par commentaires et intentionnellement introduites dans le code source. Les \ac{SATD} ne sont pas rares dans les projets logiciels et ont d\'{e}j\`{a} \'{e}t\'{e} largement \'{e}tudi\'{e}es concernant leur diffusion, impact sur la qualit\'{e} logiciel, criticit\'{e}, \'{e}volution et acteurs. Diverses m\'{e}thodes de d\'{e}tection sont pr\'{e}sentement utilis\'{e}es pour identifier les \ac{SATD} mais toutes demeurent sujet \`{a}m\'{e}lioration. Par exemple, l'utilisation de mots cl\'{e}s (\emph{e.g.: hack, fixme, todo, ugly, etc.}) dans les commentaires en relation avec les dettes techniques ou l'utilisation du \ac{NLP} combin\'{e} \`{a} l'apprentissage machine. Donc, notre \'{e}tude analyse dans quelle mesure des dettes techniques ayant d\'{e}j\`{a} \'{e}t\'{e} consciemment admises (\ac{SATD}) peuvent \^{e}tre utilis\'{e}es pour fournir des recommandations aux d\'{e}veloppeurs lorsqu'ils \'{e}crivent du nouveau code. En d'autres termes, le but est d'\^{e}tre capable de sugg\'{e}rer quand admettre des dettes techniques ou quand am\'{e}liorer du nouveau code en processus de r\'{e}daction. \par

Pour atteindre ce but, une approche d'apprentissage machine a \'{e}t\'{e} \'{e}labor\'{e}e, nomm\'{e}e \ac{TEDIOUS}, utilisant comme variables ind\'{e}pendantes divers types de m\'{e}triques d'entr\'{e}es au niveau des m\'{e}thodes de mani\`{e}re \`{a} pouvoir classifier des dettes techniques de conception avec comme oracle des \ac{SATD} connus. Le mod\`{e}le a \'{e}t\'{e} entrain\'{e} et \'{e}valuer sur neuf projets Java \emph{open source} contenant des \ac{SATD} pr\'{e}c\'{e}demment \'{e}tiquet\'{e}s. En d'autres termes, notre approche vise a pr\'{e}dire pr\'{e}cis\'{e}ment les \ac{TD} dans les projets logiciels. \par

\ac{TEDIOUS} fonctionne au niveau de granularit\'{e} des m\'{e}thodes, en d'autres termes, il d\'{e}tecte si une m\'{e}thode contient une dette de conception ou non. Il a \'{e}t\'{e} con\c{c}u ainsi car les d\'{e}loppeur ont d'avantage tendance \`{a} admettre des dettes techniques au niveau des m\'{e}thodes ou des blocs de code. Les \ac{TD} peuvent \^{e}tre classifi\'{e}s selon diff\'{e}rents types: conception, requis, test, code et documentation. Les dettes de conception seulement ont \'{e}t\'{e} consid\'{e}r\'{e}es car elles forment la majorit\'{e} et analyser chaque type demanderait une analyse personnalis\'{e}e. \par

\ac{TEDIOUS} est entra\^{i}n\'{e} avec des donn\'{e}es \'{e}tiquet\'{e}es comme \'{e}tant des \ac{SATD} ou non et test\'{e} avec des donn\'{e}es sans \'{e}tiquettes. Les donn\'{e}es \'{e}tiquett\'{e}es contiennent des m\'{e}thodes marqu\'{e}es comme \'{e}tant des \ac{SATD}, obtenues \`{a} partir de neuf projets logiciels analys\'{e}s par un autre groupe de recherche utilisant une approche \ac{NLP} et valid\'{e} manuellement. Les projets sont de diff\'{e}rentes dimensions (\emph{e.g.:} number of classes, methods, comments, etc.) et contiennent diff\'{e}rentes proportions de dettes de conception. Des m\'{e}triques sont extraits des donn\'{e}es \'{e}tiquett\'{e}es: m\'{e}triques de code source, m\'{e}triques de lisibilit\'{e} et alertes g\'{e}n\'{e}r\'{e}es par des outils d'analysis statiques. Neuf m\'{e}triques de code source ont \'{e}t\'{e} retenus pour fournir un portrait de la dimension, du couplage, de la complexit\'{e} et du nombre de composantes des m\'{e}thodes. Le m\'{e}trique de lisibilit\'{e} prend en consid\'{e}ration, entre autres, les retraits, la longueur des lignes et des identifiants. Deux outils d'analyse statique ont \'{e}t\'{e} utilis\'{e}s pour cerner de faibles pratiques de codage. \par

Le pr\'{e}traitement des m\'{e}triques est appliqu\'{e} pour retirer ceux \'{e}tant superflus et garder ceux \'{e}tant les plus pertinents par rapport \`{a} la variable d\'{e}pendante. Certaines caract\'{e}ristiques sont fortement corr\'{e}l\'{e}es entre elles et il serait redondant de toutes les conserver. D'autres subissent aucune ou trop de variations dans le contexte de notre ensemble de donn\'{e}es, elles ne seraient pas utiles pour concevoir un predicteur et sont donc supprim\'{e}es \'{e}galement. De plus, les m\'{e}triques sont normalis\'{e}s pour atteindre des valeurs de performance appr\'{e}ciables au niveau de la predictions inter-projets. Cette normalisation est n\'{e}cessaire car le code source des projets varie en terme de dimensions et complexit\'{e}. Finalement, l'ensemble de donn\'{e}es est d\'{e}s\'{e}quilibr\'{e}, ce qui signifie que le nombre de m\'{e}thodes \'{e}tiquet\'{e} comme \'{e}tant un \ac{SATD} est faible. Un sur\'{e}chantillonnage a \'{e}t\'{e} appliqu\'{e} sur la classe en minorit\'{e} pour g\'{e}n\'{e}rer de nouvelles instances artificielles \`{a} partir de celles existantes. \par

Les mod\`{e}les d'apprentissage machine sont construits \`{a} partir de l'ensemble d'entrainement et les predictions sont evalu\'{e}es \`{a} partir de l'ensemble de test. Cinq types de \emph{machine learners} ont \'{e}t\'{e} test\'{e}s: Decision Trees (J48), Bayesian classifiers, Random Forests, Random Trees and Bagging with Decision Trees. Ces mod\`{e}les ont \'{e}t\'{e} retenus pour obtenir une grande vari\'{e}t\'{e} de r\'{e}sultats, provenant de diff\'{e}rents algorithmes consid\'{e}r\'{e}s comme \'{e}tant les plus appropri\'{e}s et p\'{e}cis dans le contexte de notre \'{e}tude. \par

Globalement, le but de notre \'{e}tude est d'\'{e}valuer la performance de pr\'{e}diction des \ac{SATD} selon notre approche. La vision poursuivie est de favoriser une meilleure compr\'{e}hension et maintenabilit\'{e} du code source. La perspective est d'\^{e}tre capable de sugg\'{e}rer quand admettre un \ac{TD} ayant \'{e}t\'{e} identifi\'{e} pr\'{e}c\'{e}demment. Trois questions de recherche sont abord\'{e}es: \par

\begin{itemize}
	\item \textbf{RQ1}: Comment \ac{TEDIOUS} performe dans la recommandation de \ac{SATD} intra-projet? 
	\item \textbf{RQ2}: Comment \ac{TEDIOUS} performe dans la recommandation de \ac{SATD}  inter-projet?
	\item \textbf{RQ3}: Comment un \emph{smell detector} au niveau des m\'{e}thodes se compare avec \ac{TEDIOUS}?
\end{itemize}


Pour r\'{e}pondre \`{a} \textbf{RQ1}, une validation crois\'{e}e de dix \'{e}chantillons a \'{e}t\'{e} r\'{e}alis\'{e} sur tous les projets, ce qui signifie que chaque mod\`{e}le est entrain\'{e} sur 90\% de toutes les m\'{e}thodes d'un projet et test\'{e} sur 10\% de ceux-ci.  Le processus est r\'{e}p\'{e}t\'{e} dix fois pour r\'{e}duire l'effet du hasard. Une approche similaire est suivie pour \textbf{RQ2}, un mod\`{e}le est entra\^{i}n\'{e} avec 8 projets et test\'{e} avec 1. \par

Pour \'{e}valuer le performance de \ac{TEDIOUS}, des m\'{e}triques standards tels que la p\'{e}cision, le rappel et la mesure F1 sont calcul\'{e}s sur la classe \ac{SATD}. Ces m\'{e}triques sont bas\'{e}s sur la quantit\'{e} de vrais positifs, faux positifs et faux n\'{e}gatifs. Pour compl\'{e}ter cette \'{e}valuation, la pr\'{e}cision, le \ac{MCC} et le \ac{ROC} \ac{AUC} sont calcul\'{e}s, en partie pour tenir compte du nombre de vrais n\'{e}gatifs. Ce qui est vis\'{e} comme performance des mod\`{e}les d'apprentissage est un \'{e}quilibre entre pr\'{e}cision et rappel, de sugg\'{e}rer \emph{correctement} le plus grand nombre possible de \ac{TD} \`{a} admettre. \ac{MCC} et \ac{AUC} sont des indicateurs  utiles pour r\'{e}duire l'effet du hasard. L'importance des m\'{e}triques d'entr\'{e}es est aussi consid\'{e}r\'{e}e pour \'{e}valuer les mod\`{e}les. \par

Pour r\'{e}pondre \`{a} \textbf{RQ3}, la performance d'un \emph{smell detector}, \ac{DECOR}, a \'{e}t\'{e} \'{e}valu\'{e} selon sa capacit\'{e} \`{a} classifier des m\'{e}thodes \'{e}tiquett\'{e}es \ac{SATD} comme \'{e}tant des dettes techniques. Des odeurs au niveau des m\'{e}thodes seulement ont \'{e}t\'{e} analys\'{e}es, tout comme \ac{TEDIOUS}. Finalement, quelques faux positifs et faux n\'{e}gatifs ont \'{e}t\'{e} discut\'{e} qualitativement pour exprimer les limites de notre approche. \par

























