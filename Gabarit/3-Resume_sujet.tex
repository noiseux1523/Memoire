% Résumé du mémoire.
%
%   Le résumé est un bref exposé du sujet traité, des objectifs visés,
% des hypothèses émises, des méthodes expérimentales utilisées et de
% l'analyse des résultats obtenus. On y présente également les
% principales conclusions de la recherche ainsi que ses applications
% éventuelles. En général, un résumé ne dépasse pas quatre pages.
%
%   Le résumé doit donner une idée exacte du contenu du mémoire ou de la thèse. Ce ne
% peut pas être une simple énumération des parties du document, car il
% doit faire ressortir l'originalité de la recherche, son aspect
% créatif et sa contribution au développement de la technologie ou à
% l'avancement des connaissances en génie et en sciences appliquées.
% Un résumé ne doit jamais comporter de références ou de figures.

%TOTAL = 4 pages

\chapter*{RÉSUMÉ}\thispagestyle{headings}
\addcontentsline{toc}{compteur}{RÉSUMÉ}

\setlength{\parindent}{5ex} Les \ac{TD} sont des solutions temporaires et peu optimales introduites dans le code source d'un logiciel informatique pour corriger un probl\`{e}me rapidement au d\'{e}triment de la qualit\'{e} logiciel. Cette pratique est r\'{e}pandue pour diverses raisons: rapidit\'{e} d'impl\'{e}mentation, conception initiale des composantes, connaissances faibles du projet, inexp\'{e}rience du d\'{e}veloppeur ou pression face aux dates limites. Les \ac{TD} peuvent s'av\'{e}rer utiles \`{a} court terme, mais excessivement dommageables pour un logiciel et au niveau du temps perdu. En effet, le temps requis pour r\'{e}gler des probl\`{e}mes et concevoir du code de qualit\'{e} n'est souvent pas compatible avec le cycle de d\'{e}veloppement d'un projet. C'est pourquoi le sujet des dettes techniques a d\'{e}j\`{a} \'{e}t\'{e} analys\'{e} dans de nombreuses \'{e}tudes, plus sp\'{e}cifiquement dans l'optique de les d\'{e}tecter et de les identifier. \par

Une approche populaire et r\'{e}cente est d'identifier les dettes techniques qui sont consciemment admises dans le code. La particularit\'{e} de ces dettes, en comparaison aux \ac{TD}, est qu'elles sont explicitement document\'{e}es par commentaires et intentionnellement introduites dans le code source. Les \ac{SATD} ne sont pas rares dans les projets logiciels et ont d\'{e}j\`{a} \'{e}t\'{e} largement \'{e}tudi\'{e}es concernant leur diffusion, leur impact sur la qualit\'{e} logiciel, leur criticit\'{e}, leur \'{e}volution et leurs acteurs. Diverses m\'{e}thodes de d\'{e}tection sont pr\'{e}sentement utilis\'{e}es pour identifier les \ac{SATD} mais toutes demeurent sujettes \`{a} am\'{e}lioration. Par exemple, la recherche de mots cl\'{e}s en lien avec les dettes techniques (\emph{hack, fixme, todo, ugly, etc.}) pr\'{e}sents dans les commentaires ou l'utilisation du \ac{NLP} combin\'{e} \`{a} l'apprentissage machine. Donc, cette th\`{e}se analyse dans quelle mesure des dettes techniques ayant d\'{e}j\`{a} \'{e}t\'{e} consciemment admises (\ac{SATD}) peuvent \^{e}tre utilis\'{e}es pour fournir des recommandations aux d\'{e}veloppeurs lorsqu'ils \'{e}crivent du nouveau code. En d'autres termes, le but est d'\^{e}tre capable de sugg\'{e}rer quand admettre des dettes techniques ou quand am\'{e}liorer du code en processus de r\'{e}daction. \par

Pour atteindre ce but, une approche d'apprentissage machine a \'{e}t\'{e} \'{e}labor\'{e}e, nomm\'{e}e \ac{TEDIOUS}, utilisant comme variables ind\'{e}pendantes divers types de m\'{e}triques d'entr\'{e}es au niveau des m\'{e}thodes, de mani\`{e}re \`{a} pouvoir classifier des dettes techniques de conception avec comme oracle des \ac{SATD} connus. En d'autres termes, notre approche vise \`{a} pr\'{e}dire pr\'{e}cis\'{e}ment la pr\'{e}sence de \ac{TD} dans les projets logiciels. Le mod\`{e}le a \'{e}t\'{e} entra\^{i}n\'{e} et \'{e}valu\'{e} sur neuf projets Java \emph{open source} contenant des \ac{SATD} pr\'{e}c\'{e}demment \'{e}tiquet\'{e}s. \par

\ac{TEDIOUS} fonctionne au niveau de granularit\'{e} des m\'{e}thodes, il d\'{e}tecte si une m\'{e}thode contient une dette de conception ou non. Il a \'{e}t\'{e} con\c{c}u ainsi car les d\'{e}veloppeurs ont davantage tendance \`{a} admettre des dettes techniques au niveau des m\'{e}thodes ou des blocs de code. De plus, les \ac{TD} peuvent \^{e}tre classifi\'{e}s selon diff\'{e}rents types: conception, requis, test, code et documentation. Les dettes de conception seulement ont \'{e}t\'{e} consid\'{e}r\'{e}es car elles forment la majorit\'{e} et analyser chaque type demanderait une analyse personnalis\'{e}e. \par

\ac{TEDIOUS} est entra\^{i}n\'{e} avec des donn\'{e}es \'{e}tiquet\'{e}es comme \'{e}tant des \ac{SATD} ou non et test\'{e} avec des donn\'{e}es sans \'{e}tiquettes. Les donn\'{e}es \'{e}tiquet\'{e}es contiennent des m\'{e}thodes marqu\'{e}es comme \'{e}tant des \ac{SATD}, obtenues \`{a} partir de neuf projets logiciels analys\'{e}s par un autre groupe de recherche utilisant une approche \ac{NLP} et valid\'{e}es manuellement. Les projets sont de diff\'{e}rentes dimensions (\emph{e.g.:} number of classes, methods, comments, etc.) et contiennent diff\'{e}rentes proportions de dettes de conception. Des m\'{e}triques sont extraites des donn\'{e}es \'{e}tiquet\'{e}es: m\'{e}triques de code source, m\'{e}trique  de lisibilit\'{e} et alertes g\'{e}n\'{e}r\'{e}es par des outils d'analyse statique. Neuf m\'{e}triques de code source ont \'{e}t\'{e} retenues pour fournir un portrait de la dimension, du couplage, de la complexit\'{e} et du nombre de composantes des m\'{e}thodes. La m\'{e}trique de lisibilit\'{e} prend en consid\'{e}ration, entre autres, les retraits, la longueur des lignes et des identifiants. Deux outils d'analyse statique ont \'{e}t\'{e} utilis\'{e}s pour cerner de mauvaises pratiques de codage. \par

Un pr\'{e}traitement des m\'{e}triques est appliqu\'{e} pour retirer celles \'{e}tant superflues et garder celles \'{e}tant les plus pertinentes par rapport \`{a} la variable d\'{e}pendante. Certaines caract\'{e}ristiques sont fortement corr\'{e}l\'{e}es entre elles et il serait redondant de toutes les conserver. D'autres subissent aucune ou trop de variations dans le contexte de notre ensemble de donn\'{e}es, elles ne seraient pas utiles pour concevoir un pr\'{e}dicteur et sont donc retir\'{e}es \'{e}galement. De plus, les m\'{e}triques sont normalis\'{e}es pour atteindre des valeurs de performance appr\'{e}ciables au niveau de la pr\'{e}diction interprojets. Cette normalisation est n\'{e}cessaire car le code source des projets varie en termes de dimensions et complexit\'{e}. Finalement, l'ensemble de donn\'{e}es est d\'{e}s\'{e}quilibr\'{e}, ce qui signifie que le nombre de m\'{e}thodes \'{e}tiquet\'{e} comme \'{e}tant un \ac{SATD} est faible. Un sur\'{e}chantillonnage a \'{e}t\'{e} appliqu\'{e} sur la classe en minorit\'{e} pour g\'{e}n\'{e}rer de nouvelles instances artificielles \`{a} partir de celles existantes. \par

Les mod\`{e}les d'apprentissage machine sont construits \`{a} partir de l'ensemble d'entra\^{i}nement et les pr\'{e}dictions sont g\'{e}n\'{e}r\'{e}es \`{a} partir de l'ensemble de test. Cinq types de \emph{machine learners} ont \'{e}t\'{e} test\'{e}s: Decision Trees (J48), Bayesian classifiers, Random Forests, Random Trees and Bagging with Decision Trees. Ces mod\`{e}les ont \'{e}t\'{e} retenus pour obtenir une grande vari\'{e}t\'{e} de r\'{e}sultats, provenant de diff\'{e}rents algorithmes consid\'{e}r\'{e}s comme \'{e}tant les plus appropri\'{e}s et pr\'{e}cis dans le contexte de notre recherche. \par

Globalement, le but de cette th\`{e}se est d'\'{e}valuer la performance de pr\'{e}diction des \ac{SATD} avec notre approche. La vision poursuivie est de favoriser une meilleure compr\'{e}hension et maintenabilit\'{e} du code source. La perspective est d'\^{e}tre capable de sugg\'{e}rer quand admettre un \ac{TD} ayant \'{e}t\'{e} identifi\'{e} pr\'{e}c\'{e}demment. Trois questions de recherche sont abord\'{e}es: \par

\begin{itemize}
	\item \textbf{RQ1}: Comment \ac{TEDIOUS} performe dans la recommandation de \ac{SATD} intra-projet? 
	\item \textbf{RQ2}: Comment \ac{TEDIOUS} performe dans la recommandation de \ac{SATD} interprojet?
	\item \textbf{RQ3}: Comment un \emph{smell detector} au niveau des m\'{e}thodes se compare avec \ac{TEDIOUS}?
\end{itemize}

Pour r\'{e}pondre \`{a} \textbf{RQ1}, une validation crois\'{e}e de dix \'{e}chantillons a \'{e}t\'{e} r\'{e}alis\'{e}e sur tous les projets, ce qui signifie que chaque mod\`{e}le est entrain\'{e} sur 90\% de toutes les m\'{e}thodes d'un projet et test\'{e} sur 10\% de ceux-ci.  Le processus est r\'{e}p\'{e}t\'{e} dix fois pour r\'{e}duire l'effet du hasard. Une approche similaire est suivie pour \textbf{RQ2} o\`{u} un mod\`{e}le est entra\^{i}n\'{e} avec huit projets et test\'{e} avec un. \par

Pour \'{e}valuer la performance de \ac{TEDIOUS}, des m\'{e}triques standards telles que la pr\'{e}cision, le rappel et la mesure F1 sont calcul\'{e}es sur la classe \ac{SATD}. Ces m\'{e}triques sont bas\'{e}es sur la quantit\'{e} de vrais positifs, faux positifs et faux n\'{e}gatifs. De plus, le \ac{MCC} et le \ac{ROC} \ac{AUC} sont calcul\'{e}s, en partie pour tenir compte du nombre de vrais n\'{e}gatifs et car ils sont d'utiles indicateurs pour quantifier l'effet du hasard. Pour compl\'{e}ter cette \'{e}valuation, l'importance des m\'{e}triques d'entr\'{e}es dans la pr\'{e}diction des dettes techniques est aussi consid\'{e}r\'{e}e. Ce qui est vis\'{e} au niveau de la performance des mod\`{e}les d'apprentissage est un \'{e}quilibre entre pr\'{e}cision et rappel, donc, de sugg\'{e}rer \emph{correctement} le plus grand nombre possible de \ac{TD} \`{a} admettre. \par

Pour r\'{e}pondre \`{a} \textbf{RQ3}, la performance d'un \emph{smell detector}, \ac{DECOR}, a \'{e}t\'{e} \'{e}valu\'{e}e selon sa capacit\'{e} \`{a} classifier des m\'{e}thodes \'{e}tiquet\'{e}es \ac{SATD} comme \'{e}tant des dettes techniques. Les odeurs au niveau des m\'{e}thodes seulement ont \'{e}t\'{e} analys\'{e}es, tout comme avec \ac{TEDIOUS}. Finalement, quelques faux positifs et faux n\'{e}gatifs ont \'{e}t\'{e} analys\'{e}s qualitativement pour exprimer les limites de notre approche. \par

Pour \textbf{RQ1}, les r\'{e}sultats ont d\'{e}montr\'{e} que le classificateur Random Forest a atteint les meilleures performances pour la recommandation de dettes de conception. La pr\'{e}cision moyenne obtenue a \'{e}t\'{e} de 49.97\% et le rappel 52.19\%. Les valeurs de \ac{MCC} et \ac{AUC} pour chaque projet ont indiqu\'{e} la pr\'{e}sence de classificateurs de qualit\'{e}. \'{E}quilibrer l'ensemble de donn\'{e}es a permis d'accro\^{i}tre le rappel au d\'{e}triment de la pr\'{e}cision. La lisibilit\'{e}, la complexit\'{e} et la taille du code source ont jou\'{e} un r\^{o}le significatif dans l'\'{e}laboration des pr\'{e}dicteurs. \par

Pour \textbf{RQ2}, la pr\'{e}diction interprojet a augment\'{e} la performance des pr\'{e}dicteurs en comparaison \`{a} la validation crois\'{e}e sur des projets singuliers gr\^{a}ce \`{a} un ensemble d'entra\^{i}nement plus large et diversifi\'{e}. La pr\'{e}cision moyenne obtenue a \'{e}t\'{e} de 67.22\% et le rappel 54.89\%. Les valeurs de \ac{MCC} et \ac{AUC} ont encore une fois indiqu\'{e} la pr\'{e}sence de classificateurs de qualit\'{e}. De mani\`{e}re similaire, la lisibilit\'{e}, la taille et la complexit\'{e} ont jou\'{e} un r\^{o}le important dans l'\'{e}laboration des pr\'{e}dicteurs. \par

Pour \textbf{RQ3}, les odeurs \ac{LM} et \ac{LP} ont \'{e}t\'{e} \'{e}valu\'{e}es par \ac{DECOR}, tr\`{e}s semblables aux m\'{e}triques \ac{LOC} et nombre de param\`{e}tres qui ont jou\'{e} un r\^{o}le important dans l'entra\^{i}nement des machines d'apprentissage. Toutefois, les performances de \ac{DECOR} ne se sont pas av\'{e}r\'{e}es aussi bonnes que pour \ac{TEDIOUS}. Le score \emph{F$_{1}$} pour l'union de \ac{LM} et \ac{LP} n'a pu surpasser 22\% et la valeur \ac{MCC} a indiqu\'{e} une faible corr\'{e}lation de pr\'{e}diction. \par

Suite \`{a} ces r\'{e}sultats, nous avons d\'{e}cid\'{e} de concevoir et tester une nouvelle approche pour am\'{e}liorer la performance de \ac{TEDIOUS}. Elle est similaire \`{a} la pr\'{e}c\'{e}dente car elle est bas\'{e}e sur l'apprentissage machine, elle fonctionne au niveau des m\'{e}thodes et elle utilise des m\'{e}thodes \'{e}tiquet\'{e}es comme \ac{SATD} de conception. Toutefois, le mod\`{e}le de syst\`{e}me d'apprentissage favoris\'{e} est le \ac{CNN}, impl\'{e}ment\'{e} sp\'{e}cifiquement pour le contexte de notre recherche. Les variables ind\'{e}pendantes ne sont pas des caract\'{e}ristiques du code source mais plut\^{o}t le code source \emph{lui-m\^{e}me}. Comme pour les caract\'{e}ristiques de l'approche pr\'{e}c\'{e}dente, le code source a aussi \'{e}t\'{e} pr\'{e}trait\'{e}, il a \'{e}t\'{e} transform\'{e} en jetons et un \emph{word embedding} a \'{e}t\'{e} r\'{e}alis\'{e}. Le \ac{CNN} a \'{e}t\'{e} test\'{e} sur le m\^{e}me ensemble de donn\'{e}es, intraprojet, mais aussi selon diff\'{e}rentes variables ind\'{e}pendantes: code source avec, sans et partiellement avec commentaires. Une m\'{e}thode d'analyse similaire a aussi \'{e}t\'{e} suivie, utilisant la validation crois\'{e}e et les m\'{e}triques de performance standards. Pour les commentaires seulement, la pr\'{e}cision moyenne obtenue est 85.49\% et le rappel 62.61\%. Pour le code source avec commentaires, la pr\'{e}cision moyenne obtenue est 84.06\% et le rappel 74.50\%. Pour le code source sans commentaires, la pr\'{e}cision moyenne obtenue est 68.17\% et le rappel 26.76\%. Pour le code source partiellement avec commentaires, la pr\'{e}cision obtenue est 66.22\% et le rappel 20.65\%.

%Quelques menaces peuvent affecter la validit\'{e} de notre \'{e}tude. Pour les menaces de \emph{validit\'{e} de la construction}, les erreurs de mesure des SATD \'{e}tiquett\'{e}s et des m\'{e}triques repr\'{e}sentent un probl\`{e}me. Pour les menaces de \emph{validit\'{e} interne}, les param\`{e}tres par d\'{e}faut seulement ont \'{e}t\'{e} appliqu\'{e}s aux machines d'apprentissage. Une optimisation des param\`{e}tres pourrait \^{e}tre appliqu\'{e}e pour obtenir de meilleures configurations. L'utilisation intelligente des diagnostiques de performance (\ac{AUC}, \ac{MCC}) a permis de r\'{e}duire les menaces de \emph{validit\'{e} des conclusions}. Pour les menaces de \emph{validit\'{e} de la fiabilit\'{e}}, tous les d\'{e}tails n\'{e}cessaires sont fournis pour r\'{e}pliquer notre \'{e}tude. Pour les menaces de \emph{validit\'{e} externe}, il ne peut \^{e}tre garanti que nos r\'{e}sultats peuvent \^{e}tre g\'{e}n\'{e}ralis\'{e}s \`{a} tous les projets Java, consid\'{e}rant l'\'{e}chelle r\'{e}duite de notre \'{e}tude. Notre approche devrait \^{e}tre \'{e}tendue \`{a} d'avantage de projets, domaines et langages de programmation. \par

Pour conclure, ce m\'{e}moire d\'{e}crit \ac{TEDIOUS}, une approche d'apprentissage machine au niveau des m\'{e}thodes con\c{c}ue pour recommander quand un d\'{e}veloppeur devrait admettre un \ac{TD} de conception, bas\'{e}e sur la taille, la complexit\'{e}, la lisibilit\'{e} et l'analyse statique du code source. Pour l'approche utilisant les caract\'{e}ristiques du code source, les performances intraprojet bas\'{e}es sur 9 projets Java \emph{open source} ont men\'{e} \`{a} des r\'{e}sultats prometteurs: environ 50\% de pr\'{e}cision, 52\% de rappel et 93\% de justesse. Les performances interprojet se sont av\'{e}r\'{e}es sup\'{e}rieures: environ 67\% de pr\'{e}cision, 55\% de rappel et 92\% de justesse. L'ensemble de donn\'{e}es grandement d\'{e}s\'{e}quilibr\'{e} a repr\'{e}sent\'{e} le plus grand obstacle dans l'obtention de valeurs de performance \'{e}lev\'{e}es. Pour les projets les plus volumineux, une pr\'{e}cision et un rappel sup\'{e}rieurs \`{a} 88\% ont \'{e}t\'{e} obtenues. Pour l'approche utilisant le code source lui-m\^{e}me, les r\'{e}sultats obtenus se sont av\'{e}r\'{e}s meilleurs qu'avec TEDIOUS. Le CNN a \'{e}t\'{e} le plus performant en utilisant le code source avec commentaires, obtenant une pr\'{e}cision de 84.06\%, un rappel de 74.50\% et une justesse de 78.99\%. Il s'agit d'am\'{e}liorations de +16.84\% pour la pr\'{e}cision, +19.61\% pour le rappel et +23.56\% pour la justesse, par rapport aux m\'{e}triques de performance obtenus avec l'\'{e}valuation interprojets de TEDIOUS.

\ac{TEDIOUS} pourrait \^{e}tre utilis\'{e}e pour diverses applications. Il pourrait \^{e}tre utilis\'{e} comme syst\`{e}me de recommandation pour savoir quand documenter des \ac{TD} nouvellement introduits. Deuxi\`{e}mement, il pourrait aider \`{a} personnaliser les alertes relev\'{e}es pour les outils d'analyse statique. Troisi\`{e}mement, il pourrait compl\'{e}menter des d\'{e}tecteurs d'odeurs pr\'{e}existants pour am\'{e}liorer leur performance, comme \ac{DECOR}. Quant aux travaux futurs, un plus grand ensemble de donn\'{e}es sera \'{e}tudi\'{e} pour savoir si ajouter davantage d'information est b\'{e}n\'{e}fique aux performances de notre approche. De plus, nous planifions \'{e}tendre \ac{TEDIOUS} \`{a} la recommandation de davantage de types de dettes techniques.























