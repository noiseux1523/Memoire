%   Dans l'introduction, on présente le problème étudié et les buts
% poursuivis. L'introduction permet de faire connaître le cadre de la
% recherche et d'en préciser le domaine d'application. Elle fournit
% les précisions nécessaires en ce qui concerne le contexte de
% réalisation de la recherche, l'approche envisagée, l'évolution de
% la réalisation. En fait, l'introduction présente au lecteur ce
% qu'il doit savoir pour comprendre la recherche et en connaître la
% portée.

%TOTAL = 8 pages

\Chapter{INTRODUCTION}\label{sec:Introduction}  
%%
%% BRINGING THE SUBJECT
%%

%0.5 page

\setlength{\parindent}{5ex} In today's consumer society, products have to be designed and ready to hit the market as fast as possible in order to stand out from other similar products and generate sells. This pressure to produce can affect the quality, maintainability and functionality of the design. In software engineering, the repercussion of this mindset can be measured with the amount of technical debts present in a project. These \ac{TD} can go unnoticed, which is the danger behind them, or may be admitted by developers. In fact, studies have been conducted on technical debts that are "self-admitted" by developers, commenting why such code represent an issue or a temporary solution. The subject of this paper is to study how previously self-admitted technical debts can be used to recommend when to admit a newly introduced \ac{TD}.

%%
%%  CONCEPTS DE BASE
%%
\section{Basic Concepts and Defintions}  

%environ 3 pages

\setlength{\parindent}{5ex} Technical debts are temporary and less than optimal solutions introduced in the code. They are portions of code that still need to be worked on even though they accomplish the purpose they were written for. As Cunningham first described them, \ac{TD} is "not quite right code which we postpone making it right" \citep{Cunningham:1992:WPM:157709.157715}. For example, \ac{TD} could be workarounds which don't follow good coding practices, poorly structured or hard-to-read code. By definition, technical debts don't typically cause errors, preventing the code from working, but they can in some circumstances. Various reasons can motivate the introduction of technical debts: to rapidly fix an issue, development team is at the early stages of conception, lack of comprehension, skills or experience \citep{Suryanarayana20151}. \ac{TD} are introduced throughout the whole development life cycle and under various forms. An ontology and landscape have been built to better define the subject. Design, requirement, code, test and documentation debts represent the main branches of the classification tree \citep{alves2014towards,izurieta2012organizing}. Each branch can be linked to a specific development stage and to specific criteria. For example, design debt "refers to debt that can be discovered by analyzing the source code by identifying the use of practices which violated the principles of good object-oriented design (e.g. very large or tightly coupled classes)" \citep{alves2014towards}. \par

Other work investigated the perception of developers on technical debts. It was found that the most important source of \ac{TD} is architectural decisions, that recognizing the phenomenon is essential for communication and that there is a lack of tools to manage those debts \citep{Ernst:2015:MMI:2786805.2786848}. Additionally, project teams recognize that this issue is unavoidable and necessary \citep{lim2012balancing}.


%Technical debt
%	Defintion TD (Cunningham 15)
%	Definition classes TD (3 et 22)
%	Nature intentionnelle des TD (24)
%	Awareness des TD est un probleme (17)
%	
%Self admitted technical debt
%	Definition SATD (Potdar 16 et 35)
%	Presence des SATD (Potdar 16 et 35)
%	Acteurs des SATD (Potdar 16 et 35)
%	Correlation qualite/SATD (Bavota et Russo 8, 10)
%	Taxonomie des SATD (Bavota et Russo 8)
%	
%Features
%	Structural metrics of methods
%	Method readability
%	Warnings of static analysis tools (Checkstyle 1, PMD 2)	
%	
%Dataset
%	9 java open source projects from (27), only design debts
%	
%Machine Learners
%	5 machine learners, with fold validation and cross project
%	
%Results
%	50\% precision and 52\% recall within project with RandomForest
%	67\% precision, 55\% recall, 92\% accuracy cross project
%	Can be applied on new projects and be good
		


%%
%% ELEMENTS DE LA PROBLEMATIQUE
%%
\section{Éléments de la problématique}  

environ 3 pages

%La description de \mbox{l'en-tête} commun de RSVP est détaillée ci-dessous:\\
%\begin{tabular}{p{1in}p{4.5in}}
%&\\ % Ligne vide
%\texttt{Ver}: & \texttt{4 bits}\\
%          & Version du protocole. La version actuelle est~1.\\[5pt]
%\texttt{Flags}: & \texttt{4 bits}\\
%          & Aucun Flag n'est défini. L'émetteur doit (\textbf{MUST})
%          mettre le champ à zéro et le récepteur doit (\textbf{MUST})
%          ignorer ce champ.\\[5pt]
%\texttt{Msg Type}: & \texttt{8 bits}\\
%          & Type de message\\[5pt]
%\texttt{Checksum}: & \texttt{16 bits}\\
%          & Complément à un du complément à un de la somme des champs
%          de \mbox{l'en-tête}, avec le champ Checksum à~0 pour des
%          fins de calcul. La valeur~0 signifie qu'aucun Checksum n'a
%          été transmis. Si le résultat du calcul du Checksum donne~0,
%          la valeur 0xFFFF doit être stockée dans ce champ.\\[5pt]
%\texttt{TTL}: & \texttt{8 bits}\\
%          & Valeur originelle du champ \texttt{TTL} utilisée pour
%          transmettre ce message.\\[5pt]
%\texttt{Reserved}: & \texttt{8 bits}\\
%          & Réservé pour usage futur. L'émetteur doit (\textbf{MUST})
%          mettre le champ à zéro et le récepteur doit (\textbf{MUST})
%          ignorer ce champ.\\[5pt]
%\texttt{Length}: & \texttt{16 bits}\\
%          & Longueur totale du message en octets, incluant
%          \mbox{l'en-tête} commun et tous les objets de longueur
%          variable.
%\end{tabular}

%\subsection{Autres types de structures de données}
%L'énumération:
%\begin{enumerate}
%\item Un item~;
%\item Un autre item.
%\end{enumerate}


%\subsection{Le protocole IPv6}
%Voir la Figure~\ref{fig:IPv6} pour plus de détails. Le champs DSCP est
%décrit dans le Tableau~\ref{tab:RangesDSCP}.
%
%\begin{figure}[htb]
%\centering
%\includegraphics[width=4in]{IPv6_header}
%\caption{L'en-tête IPv6}
%\label{fig:IPv6}
%\end{figure}
%
%\begin{table}[ht]
%\caption{Plages de valeurs pour le champ \texttt{DSCP}}
%\centering
%\begin{tabular}{|c|c|l|}
%\hline\rowcolor[gray]{0.8}\color{black}
%Plage & Valeurs & Règle d'assignation\\\hline
%1 & xxxxx0 & Assignation par une norme de l'IANA\\\hline
%2 & xxxx11 & Expérimentation/Usage local\\\hline
%3 & xxxx01 & Expérimentation/Usage local (pourrait être jointe à la plage 1)\\\hline
%\end{tabular}
%\label{tab:RangesDSCP}
%\end{table}
%
%% On veut éviter que la figure et le tableau soient placés au-delà de la section courante.
%\FloatBarrier


%%
%% OBJECTIFS DE RECHERCHE
%%
\section{Objectifs de recherche}  

0.5 page

TEDIOUS (TEchnical Debt IdentificatiOn System)
	Supervised Machine Learning approach
	Method-level
	Using various features of code source (independant)
	Knowledge of previous SATD (dependant)
	To recommend developpers with TD to be admitted
	
Purpose
	1) Encourage self admitting TD (mainly done by experienced, want new to do too 35)
	2) Alternative to smell detectors to give opportunities to improve source code
	
Difference
	1) Method-level instead of class-level metrics (8) because SATD comments at method or block-level mainly
	2) Only consider certain types of TD (design debt since largest 27)
		Other types for future since different analysis
		

	
	

%Les objectifs de la recherche sont de concevoir un algorithme $O(n)$.

%%
%% PLAN DU MEMOIRE
%%
\section{Plan du mémoire}  

0.5 page

%Un tableau:
%\begin{table}[htbp]
%  \centering
%  \caption{Constantes et variables du modèle analytique}
%  \begin{tabular}{|c|l|}
%    \hline\rowcolor[gray]{0.8}\color{black}
%    Symbole         & Description\\\hline
%    $\lambda$       & Taux d'arrivée moyen des requêtes de réservation de ressources\\\hline
%    $\frac{1}{\mu}$ & Durée moyenne d'une session\\\hline
%    $C$             & Capacité d'une cellule (nombre de sessions supportées)\\\hline
%    $v_{moy}$       & Vitesse moyenne des MN dans le réseau d'accès\\\hline
%    $L$             & Longueur d'un côté d'une cellule carrée\\\hline
%    $n$             & Nombre moyen de MN dans une cellule\\\hline
%    $\rho$          & Charge d'une cellule\\\hline
%    $P_b$           & Probabilité de blocage d'une requête de réservation\\\hline
%    $P_f$           & Probabilité d'interruption forcée d'une session\\\hline
%    $P_c$           & Probabilité de compléter une session avec succès\\\hline
%    $\Delta{}T$     & Délai de transmission\\\hline
%  \end{tabular}
%  \label{tab:Definitions}
%\end{table}
%
%La formule d'\mbox{Erlang-B}:
%\begin{equation}
%  P_b = \frac{\frac{\rho^C}{C!}}{\sum\limits_{x=0}^{C}\frac{\rho^x}{x!}}
%  \label{eq:Pblock}
%\end{equation}
%
%Une autre équation:
%\begin{equation}
%  \begin{split}
%    P_c &= (1 - P_b) \times (1 -  P_f)^N\\
%        &= (1 - P_b)^{N+1}
%  \end{split}
%  \label{eq:ProbComplete}
%\end{equation}
%
%Enfin, l'expression suivante indique le moment à partir duquel les
%réservations de ressources sont en place:
%\begin{equation}
%  \Delta{}T_{init} =
%  \begin{cases}
%    2\Delta{}T_{E2E} & \Delta{}T_{wan} > (\Delta{}T_{rad} + \Delta{}T_{net})\\
%    \Delta{}T_{E2E} + 3(\Delta{}T_{rad} + \Delta{}T_{net}) & \text{sinon}
%  \end{cases}
%  \label{eq:InitCost}
%\end{equation}
%
%\paragraph{Le taux de paquets perdus} correspond au nombre de paquets
%éliminés à cause d'une erreur de \emph{checksum} à un n\oe{}ud
%quelconque ou d'une situation de congestion. Le taux de paquets perdus
%pour un chemin est déterminé de la façon suivante:
%\begin{equation}
%  \label{eq:genPLR}
%  PLR_P = 1 - \prod_{i=1}^N(1 - PLR_i)
%\end{equation}
%
%Toutefois, si les taux d'erreurs sont très faibles, comme c'est
%généralement le cas pour des liens optiques, on peut approximer
%$PLR_P$ de façon à le transformer en un paramètre additif:
%\begin{equation}
%  \label{eq:approxPLR}
%  \begin{split}
%    PLR_{L_1 \oplus L_2} &= 1 - (1 - PLR_1)(1 - PLR_2)\\
%    &= 1 - (1 - PLR_2 - PLR_1 + \underbrace{PLR_1
%      \times PLR_2}_\text{négligeable})\qquad PLR_1 \ll 1,
%    PLR_2 \ll 1\\
%    &\approx PLR_1 + PLR_2
%  \end{split}
%\end{equation}
%
%\clearpage
%
%Une courbe:
%\begin{figure}[htb]
%\centering
%\includegraphics[width=5in]{LinkUsage}
%\caption{Délai moyen en fonction du taux d'utilisation d'un lien}
%\label{fig:LinkUse}
%\end{figure}
%
%\selectlanguage{english}
%This paragraph is formatted by \LaTeX{} according to the standard rules of the
%English language (\mbox{e.g.} hyphenation).
%\selectlanguage{french}
%
%L'arithmétique en virgule flottante peut entraîner des erreurs
%d'approximation et il est important d'en être conscient
%\citep[voir][]{Goldberg1991}.
%
%De même, les calculs effectués sur une carte graphique (GPU) peuvent
%introduire des erreurs d'approximation \citep{Benz2012, DSilva2012,
%  Dabrowski2011, DeDinechin2011, DeFigueiredo2004, Filliatre2007,
%  Fousse2007, Goubault2001, Goubault2008, Harder, Higham2002, Tanenbaum,
%  Whitehead2011, mpmath, nichols2010, nvidia2012, Benz2012, Bao2013}.
