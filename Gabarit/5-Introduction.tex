% Dans l'introduction, on présente le problème étudié et les buts
% poursuivis. L'introduction permet de faire connaître le cadre de la
% recherche et d'en préciser le domaine d'application. Elle fournit
% les précisions nécessaires en ce qui concerne le contexte de
% réalisation de la recherche, l'approche envisagée, l'évolution de
% la réalisation. En fait, l'introduction présente au lecteur ce
% qu'il doit savoir pour comprendre la recherche et en connaître la
% portée.

% TOTAL = 8 pages

%%
%% BRINGING THE SUBJECT
%%
\Chapter{INTRODUCTION}\label{sec:Introduction}  

% 0.5 page

\setlength{\parindent}{5ex} In today's consumer society, products have to be designed and ready to hit the market as fast as possible, in order to stand out from other similar products and generate revenues. This pressure to produce can affect the quality, maintainability and functionality of the design. In software engineering, the repercussion of this mindset can be, in a certain way, measured with the amount of technical debts present in a project. The problem is that these \ac{TD} can frequently go unnoticed if they are not admitted. In fact, studies have been conducted on technical debts that are "self-admitted", where developers comment why such code represent an issue or a temporary solution. In a similar vein, the subject of this thesis is to study how previously self-admitted technical debts can be used to recommend when to admit newly introduced technical debts.

%%
%%  CONCEPTS DE BASE
%%
\section{Basic Concepts and Definitions}  

% environ 3 pages

\setlength{\parindent}{5ex} Technical debts are temporary and less than optimal solutions introduced in the code. They are portions of code that still need to be worked on even though they accomplish their purpose. \citet{Cunningham:1992:WPM:157709.157715} first described technical debts as "not quite right code which we postpone making it right". For example, \ac{TD} can be workarounds which don't follow good coding practices, poorly structured code or hard-to-read code. By definition, technical debts don't typically cause errors or prevent the code from working but they can in some circumstances. However, various reasons can motivate the introduction of technical debts: to rapidly fix an issue, because the development team is at early stages of conception, because of a lack of comprehension, skills or experience \citep{Suryanarayana20151}. \par

\ac{TD} are introduced throughout the whole conception timeline and under various forms, partly because writing quality code is not always compatible with the standard development life cycle \citep{brown2010managing}. That is why an ontology and landscape was proposed by \citet{alves2014towards} and \citet{izurieta2012organizing} to better define the subject. In this ontology, design, requirement, code, test and documentation debts represent the main branches of the classification tree, where each branch can be linked to a specific development stage and to specific criteria. For example, \emph{design debt} "refers to debt that can be discovered by analyzing the source code by identifying the use of practices which violated the principles of good object-oriented design (e.g. very large or tightly coupled classes)" \citep{alves2014towards}. \par

Other studies investigated the perception of developers on technical debts. \citet{Ernst:2015:MMI:2786805.2786848} found that the most important source of \ac{TD} are architectural decisions, that recognizing the phenomenon is essential for communication and that there is a lack of tools to manage those debts. Additionally, software project teams recognize that this issue is unavoidable and necessary \citep{lim2012balancing} and that they cause a lot of problems. For example, slower conception and execution of the software product \citep{allman2012managing}, diminished software maintainability and quality \citep{wehaibi2016examining,zazworka2011investigating}, and higher production cost \citep{guo2011tracking}. \par

Frequently, \ac{TD} are introduced consciously and explicitly by developers. In those cases, they are "self-admitted" and explained in comments, describing what is wrong with the related block of code \citep{PotdarS14}. Like technical debts, SATD are encountered in most software projects. It was found that 31\% of files contain \ac{SATD}, that they remain in the source code for a long period of time and that experienced developers are more prone to introducing them \citep{PotdarS14}. This proves that a proper management tool is required to deal with this issue, and that unexperienced developers would greatly benefit from such support in order to decide when code should be reworked and documented as \ac{TD}. The disparity between the experienced and unexperienced workers may also lie in the fact that the unexperienced ones don't want to admit their faults in order to maintain a positive image towards their superiors. \par

\citet{BavotaR16} found that there is no clear correlation between code quality and \ac{SATD}. Code quality metrics such as \ac{WMC}, \ac{CBO} and Buse and Weimer Readability \citep{Buse:tse2010} were computed and analyzed to reach this conclusion. However, the primary purpose of this work was not to evaluate this relationship but rather to establish a taxonomy of \ac{TD}. Some threats to the validity of their results could also be made concerning the number of manually analyzed \ac{SATD} and the level at which the metrics were computed (class-level). A finer analysis would have been required because a single class can contain methods of different length, complexity, cohesion, coupling and readability. This same study found an average of 51 instances of \ac{SATD} (0.3\% of all comments) in the analyzed projects, that the developer who introduces a \ac{TD} is generally the same that fixes it and that they aren't all fixed during the development life cycle. \par


%%
%% ELEMENTS DE LA PROBLEMATIQUE
%%
\section{Elements of the Problematic}  

% environ 3 pages

It is pretty clear that technical debts account for a lot of issues in the development of software applications. They have been extensively analyzed and classified in order to have a better understanding of their impact. However, the identification, as much as the \emph{correct} identification of \ac{SATD}, remains a struggle for researchers and developers. Current methods can obtain up to 25\% of their total predictions as false positives \citep{BavotaR16}. This means that a quarter of all automatically identified \ac{TD} are not really technical debts. Consequently, conclusions made by studies using these results could be erroneous considering the high level of false technical debts. 

Additionally, many strategies can be employed to reduce the number of TD and fix them: take your time when implementing a solution, code refactoring, continuous tracking of \ac{TD}, proactiveness in fixing debts, etc. \citep{Ambler}. However, they are not highly effective and frequently rely on the willingness of developers to fix the problem and their general knowledge. \par

To cope with these low accuracy values, various approaches have been proposed to improve the detection of \ac{TD}. One of them is to identify comment patterns that relate to self-admitted technical debts \citep{PotdarS14}. Potdar \emph{et al.} manually went through 101 762 comments to determine them, which lead to the identification of 62 \ac{SATD} patterns, for example, \emph{hack, fixme, is problematic, this isn't very solid, probably a bug}. The main issue with this approach is the manual process behind it, which introduces human error and subjectivity. Another approach proposed by \citet{MaldonadoNLP} is to use machine learning techniques combined with \ac{NLP} to automatically identify \ac{SATD} using source code comments. This idea is promising because it does not heavily depend on the manual classification of source code comments and in fact, it outperforms the previous approach. Manual classification is still required to build the training set for the NLP classifier but the model built from this dataset can then be used to automatically identify \ac{SATD} in any project, making irrelevant any further manual analysis. \par

It is important to mention that our research does not revolve on proposing a new technical debts detection method using information contained in comments, but rather using these identified SATD as a base for our recommendation tool. Consequently, the proper classification of \ac{SATD} methods used by \ac{TEDIOUS} will directly affect its performance. 

To properly establish the problematic of this thesis and prior to designing our approach, several research questions have to be addressed. The main one can be defined like this:  \par

\begin{center}
\begin{framed}
	\noindent How can we identify and detect technical debts in a software project using source code features and known self-admitted technical debts with a machine learning approach?
\end{framed}
\end{center}

Consequently, in the quest of helping programmers, we designed and developed TEDIOUS, a machine learning inspired recommendation systems that uses manually labeled training data to detect method-level technical debts. The goal of this thesis is then to assess the performance of TEDIOUS in recommending SATD. Three other high level research questions can be derived from the main one:

\begin{center}
\begin{framed}
	 \noindent How does \ac{TEDIOUS} work for recommending \ac{SATD} within-project? \\
	 How does \ac{TEDIOUS} work for recommending SATD across-project? \\
	 How would a method-level smell detector compare with \ac{TEDIOUS}?
\end{framed}
\end{center}
	
The evaluation goal can be addressed by these questions. Firstly, we want to evaluate the detection performance of a model trained with features from the source code of a specific system on himself. Secondly, we want to perform a similar performance evaluation on a model trained with features from several systems on another unrelated system. Finally, we want to compare the detection performance of TEDIOUS with other popular smell detectors.

Our approach is based on the hypothesis that current methods to detect technical debts are limited and inefficient, and that a new approach could be beneficial to the improvement of detection performance. We also think that manual analysis and human subjectivity is detrimental to the efficiency of current methods. Consequently, we believe that a well crafted machine learning approach could lead to better results and performance values in identifying technical debts and recommending when they should be self-admitted. \par

%%
%% OBJECTIFS DE RECHERCHE
%%
\section{Research Objectives}  

% 0.5 page

\begin{center}
\begin{framed}
	\noindent The objective of this research is to design a machine learning approach that uses as independent variables various kinds of source code features, and as dependent variables the knowledge of previously self-admitted technical debts, to train machine learners in recommending to developers when a technical debt should be admitted.
\end{framed}
\end{center}

As mentioned previously, the purpose of this thesis is not to propose a novel method to identify SATD from source code comments using patterns or \ac{NLP} \citep{MaldonadoNLP,PotdarS14}. It is more about using these classified SATD comments to build our labeled dataset consisting of methods' source code information and metrics to identify possible technical debts to self-admit. \par
 
The main objective can be divided in two application scenarios. Firstly, tracking and managing technical debts is considered important but lacking in the industry \citep{Ernst:2015:MMI:2786805.2786848}. Consequently, \ac{TEDIOUS} could be used to encourage developers to self-admit \ac{TD} in order to easily track and fix the issues later. This is particularly true for junior developers, who are less prone to self-admitting than experienced ones \citep{PotdarS14}. Secondly, our tool could be used as an alternative, or a complement, to existing smell detectors in proposing improvements to source code. In other words, \ac{TEDIOUS} could act as a tracking, managing and improvement tool for software projects. \par

%%
%% OBJECTIFS DE DESIGN
%%
\section{Design Objectives} 

The five research objectives can be achieved by following this design methodology. The first one aims at \emph{defining and extracting relevant features from methods}. These features are characteristics that describe each method. Contrary to previous studies \citep{BavotaR16}, \ac{TEDIOUS} works at method-level rather than class-level because we found that \ac{SATD} comments are more frequently related to methods or blocks of code. We investigated a set of method structural metrics, a method readability metric and warning raised by static analysis tools. \par

The second specific objective aims at \emph{identifying self-admitted technical debts}. Only one type of technical debt is considered for various reasons, the design debt. Firstly, it is the most common type of \ac{TD} \citep{MaldonadoNLP}. Secondly, the other types (requirement, code, test and documentation) would require a different analysis and other training features. However, these types are planned to be analyzed in our future work. To identify SATD methods, TEDIOUS reuses knowledge of manually labeled TD, metrics, and static analysis warnings. In fact, the training set was extracted from the manually labeled corpus of 9 open source Java projects provided by \citet{MaldonadoNLP}.

The third specific objective aims at \emph{preprocessing the features}. Strongly correlated features are cleaned up to remove redundancy, metrics that don't vary or vary too much are removed, a normalization is applied to take into account the different nature of projects and the training set is balanced by oversampling the small number of \ac{SATD} tagged methods. \par

The fourth specific objective aims at \emph{building and applying machine learning models}. Five machine learners are trained and tested, performing \ac{SATD} prediction within-project and across-project. The five retained ML are: Decision Trees (J48), Bayesian classifiers, Random Forests, Random Trees and Bagging with Decision Trees. \par

We could add another objective which aims at \emph{improving the first \ac{TEDIOUS} approach}. To do so, a Convolutionnal Neural Network is designed and implemented, using the source code itself as the independent variable. It is tested using the same dataset, within-project and across-project, and with different independent variable configurations: with, without or partially with comments. Results show improvement compared to the previous approach, in terms of precision, recall, $F_1$ score and accuracy.

%%
%% PLAN DU MEMOIRE
%%
\section{Thesis Overview}  

% 0.5 page

\paragraph{Chapter 2: Literature Review}
The literature review provides a current state-of-the-art overview of the knowledge on technical debts and other related topics. It summarizes relevant information extracted from previous studies concerning four main topics: relationship between technical debt and source code metrics, self-admitted technical debt, code smell detection and automated static analysis tools.

\paragraph{Chapter 3: The Approach and Study Definition}
The approach followed is thoroughly described in several steps. The types of features are described and the way they are extracted is explained. The provenance and identification of the \ac{SATD} tagged comments is shared. The preprocessing that is performed on features is demystified and justified. The machine learning models chosen are revealed as well as their configuration. As for the study definition, the dataset characteristics (number of files, classes, comments, etc.) are shared for each project and the analysis method (cross validation, accuracy, precision, recall, F$_{1}$ score, \ac{MCC}, \ac{ROC}, \ac{AUC}) explained.

\paragraph{Chapter 4: Analysis of Study Results and Threats to Validity}
The study results are analyzed based on each research question: performance for within-project prediction, performance for across-project prediction and comparison with a method-level smell detector. Results indicate that within-project prediction achieves at best 50\% precision and 52\% recall. Improvement is made for across-project prediction where prediction achieves at best 67\% precision and 55\% recall. The best machine learner turned out to be Random Forest. It was also found that \ac{SATD} predictions made by \ac{TEDIOUS} only weakly relate to method-level code smells. A qualitative discussion on false positives and negatives is also proposed. Following the results analysis, several threats to validity are shared: construct, internal, conclusion and external validity threats.

\paragraph{Chapter 5: Convolutionnal Neural Network with Comments and Source Code} This chapter describes an updated approach to detect \ac{TD} to self-admit and its preliminary results. First, the \ac{CNN} characteristics and features are described. Secondly, the approach is explained: the features used, the identification of \ac{SATD}, the use of word embeddings and the way the \ac{CNN} is built and applied to the context of our research. Thirdly, the study definition is described: the characteristics of the dataset and the analysis method. Finally, the study results are analyzed based on three prediction contexts: source code with comments, without comments and partially with comments. Various \ac{CNN} configurations are also analyzed. Results indicate that source code with comments obtains the best performance values. It achieves 96.38\% precision, 82.40\% recall and 99.44\% accuracy.









