%%
%%  Annexes.
%%
%%  Note: Ne pas modifier la ligne ci-dessous.
\addcontentsline{toc}{compteur}{APPENDICES}
%%
%%
%%  Toutes les annexes doivent être inclues dans ce document
%%  les unes à la suite des autres.
\Annexe{Code of Qualitatively Analyzed Methods}
%Texte de l'annexe A\@. Remarquez que la phrase précédente se termine
%par une lettre majuscule suivie d'un point. On indique explicitement
%cette situation à \LaTeX{} afin que ce dernier ajuste correctement
%l'espacement entre le point final de la phrase et le début de la
%phrase suivante.
%
%
%\begin{landscape}
%\Annexe{ENCORE UNE ANNEXE}
%Texte de l'annexe B\@ en mode «landscape».
%\end{landscape}
%
%\Annexe{UNE DERNIÈRE ANNEXE}
%Texte de l'annexe C\@.

Method \textit{invokeFeature} in class \textsc{ModelAccessModelInterpreter} of \textsc{ArgoUML} project.

\begin{mdframed}
\begin{lstlisting}
/*
* @see org.argouml.profile.internal.ocl.ModelInterpreter#invokeFeature(
*	   java.util.Map,
*      java.lang.Object, java.lang.String, java.lang.String,
*      java.lang.Object[])
*/
@SuppressWarnings("unchecked")
public Object invokeFeature(Map<String, Object> vt, Object subject,
String feature, String type, Object[] parameters) {
	
	// TODO: This is an absurdly long method! Break it up.
	
	if (subject == null) {
		subject = vt.get("self");
	}
	
	/* 4.5.2.1 Abstraction */  
	// TODO investigate: Abstraction.mapping is not in the Model Subsystem
	
	/* 4.5.2.3 Association */  
	
	if (Model.getFacade().isAAssociation(subject)) {
		if (type.equals(".")) {
			if (feature.equals("connection")) {
				return new ArrayList<Object>(Model.getFacade()
				.getConnections(subject));
			}
			
			// Additional Operation 4.5.3.1 [1]
			if (feature.equals("allConnections")) {
				return new HashSet<Object>(Model.getFacade()
				.getConnections(subject));
			}                              
		}                       
	}
	
	/* 4.5.2.5 AssociationEnd */  
	
	if (Model.getFacade().isAAssociationEnd(subject)) {
		if (type.equals(".")) {
			if (feature.equals("aggregation")) {
				return Model.getFacade().getAggregation1(subject);
			}
			if (feature.equals("changeability")) {
				return Model.getFacade().getChangeability(subject);
			}
			if (feature.equals("ordering")) {
				return Model.getFacade().getOrdering(subject);
			}
			if (feature.equals("isNavigable")) {
				return Model.getFacade().isNavigable(subject);
			}
			if (feature.equals("multiplicity")) {
				return Model.getFacade().getMultiplicity(subject);
			}
			// TODO: isStatic in UML 2.x
			if (feature.equals("targetScope")) {
				return Model.getFacade().getTargetScope(subject);
			}
			if (feature.equals("visibility")) {
				return Model.getFacade().getVisibility(subject);
			}
			if (feature.equals("qualifier")) {
				return Model.getFacade().getQualifiers(subject);
			}
			if (feature.equals("specification")) {
				return Model.getFacade().getSpecification(subject);
			}                
			if (feature.equals("participant")) {
				return Model.getFacade().getClassifier(subject);
			}
			
			// TODO investigate the "unnamed opposite end"
			
			// Additional Operation 4.5.3.3 [1]
			if (feature.equals("upperbound")) {
				return Model.getFacade().getUpper(subject);
			}
			
		}
	}
	
	/* 4.5.2.6 Attribute */  
	
	if (Model.getFacade().isAAttribute(subject)) {
		if (type.equals(".")) {
			if (feature.equals("initialValue")) {
				return Model.getFacade().getInitialValue(subject);
			}
			if (feature.equals("associationEnd")) {
				return new ArrayList<Object>(Model.getFacade()
				.getAssociationEnds(subject));
			}
		}
	}
	
	/* 4.5.2.7 BehavioralFeature */  
	
	if (Model.getFacade().isABehavioralFeature(subject)) {
		if (type.equals(".")) {
			if (feature.equals("isQuery")) {
				return Model.getFacade().isQuery(subject);
			}
			if (feature.equals("parameter")) {
				return new ArrayList<Object>(Model.getFacade()
				.getParameters(subject));
			}
		}
		
		// TODO implement additional operations in 4.5.3.5
	}
	
	/* 4.5.2.8 Binding */  
	
	if (Model.getFacade().isABinding(subject)) {
		if (type.equals(".")) {
			if (feature.equals("argument")) {
				return Model.getFacade().getArguments(subject);
			}
		}
	}        
	
	/* 4.5.2.9 Class */  
	
	if (Model.getFacade().isAClass(subject)) {
		if (type.equals(".")) {
			if (feature.equals("isActive")) {
				return Model.getFacade().isActive(subject);
			}
		}
	}        
	
	/* 4.5.2.10 Classifier */  
	
	if (Model.getFacade().isAClassifier(subject)) {
		if (type.equals(".")) {
			if (feature.equals("feature")) {
				return new ArrayList<Object>(Model.getFacade()
				.getFeatures(subject));
			}
			if (feature.equals("feature")) {
				return new ArrayList<Object>(Model.getFacade()
				.getFeatures(subject));
			}
			if (feature.equals("association")) {
				return new ArrayList<Object>(Model.getFacade()
				.getAssociationEnds(subject));
			}                
			if (feature.equals("powertypeRange")) {
				return new HashSet<Object>(Model.getFacade()
				.getPowertypeRanges(subject));
			}
			// TODO specifiedEnd??
			if (feature.equals("feature")) {
				return new ArrayList<Object>(Model.getFacade()
				.getFeatures(subject));
			}
			
			// Additional Operations in 4.5.3.8
			if (feature.equals("allFeatures")) {
				return internalOcl(subject, vt, "self.feature->union("
				+ "self.parent.oclAsType(Classifier).allFeatures)");
			}
			
			if (feature.equals("allOperations")) {
				return internalOcl(subject, vt, "self.allFeatures->"
				+ "select(f | f.oclIsKindOf(Operation))");
			}
			
			if (feature.equals("allMethods")) {
				return internalOcl(subject, vt, "self.allFeatures->"
				+ "select(f | f.oclIsKindOf(Method))");
			}
			
			if (feature.equals("allAttributes")) {
				return internalOcl(subject, vt, "self.allFeatures->"
				+ "select(f | f.oclIsKindOf(Attribute))");
			}
			
			if (feature.equals("associations")) {
				return internalOcl(subject, vt, 
				"self.association.association->asSet()");
			}
			
			if (feature.equals("allAssociations")) {
				return internalOcl(
				subject,
				vt,
				"self.associations->union("
				+ "self.parent.oclAsType(Classifier).allAssociations)");
			}
			
			if (feature.equals("oppositeAssociationEnds")) {
				return internalOcl(subject, vt,
				"self.associations->select ( a | a.connection->select "
				+ "( ae | ae.participant = self ).size = 1 )->"
				+ "collect ( a | a.connection->"
				+ "select ( ae | ae.participant <> self ) )->"
				+ "union ( self.associations->"
				+ "select ( a | a.connection->select ( ae |"
				+ "ae.participant = self ).size > 1 )->"
				+ "collect ( a | a.connection) )");
			}
			
			if (feature.equals("allOppositeAssociationEnds")) {
				return internalOcl(
				subject,
				vt,
				"self.oppositeAssociationEnds->"
				+ "union(self.parent.allOppositeAssociationEnds )");
			}                 
			
			if (feature.equals("specification")) {
				return internalOcl(
				subject,
				vt,
				"self.clientDependency->"
				+ "select(d |"
				+ "d.oclIsKindOf(Abstraction)"
				+ "and d.stereotype.name = \"realization\" "
				+ "and d.supplier.oclIsKindOf(Classifier))"
				+ ".supplier.oclAsType(Classifier)");
			}                 
			
			if (feature.equals("allContents")) {
				return internalOcl(subject, vt,
				"self.contents->union("
				+ "self.parent.allContents->select(e |"
				+ "e.elementOwnership.visibility = #public or true or "
				+ " e.elementOwnership.visibility = #protected))");
			}                 
			
			if (feature.equals("allDiscriminators")) {
				return internalOcl(subject, vt,
				"self.generalization.discriminator->"
				+ "union(self.parent.oclAsType(Classifier)."
				+ "allDiscriminators)");
			}
		}
	}
	
	/* 4.5.2.11 Comment */  
	
	if (Model.getFacade().isAComment(subject)) {
		if (type.equals(".")) {
			if (feature.equals("body")) {
				return Model.getFacade().getBody(subject);
			}
			if (feature.equals("annotatedElement")) {
				return new HashSet<Object>(Model.getFacade()
				.getAnnotatedElements(subject));
			}
		}
	}
	
	/* 4.5.2.12 Component */  
	
	if (Model.getFacade().isAComponent(subject)) {
		if (type.equals(".")) {
			if (feature.equals("deploymentLocation")) {
				return new HashSet<Object>(Model.getFacade()
				.getDeploymentLocations(subject));
			}
			if (feature.equals("resident")) {
				// TODO check this
				return new HashSet<Object>(Model.getFacade()
				.getResidents(subject));
			}
			
			// TODO implementation?
			
			// Additional Operation in 4.5.3.9                
			if (feature.equals("allResidentElements")) {
				return internalOcl(subject, vt,
				"self.resident->union("
				+ "self.parent.oclAsType(Component)."
				+ "allResidentElements->select( re |"
				+ "re.elementResidence.visibility = #public or "
				+ "re.elementResidence.visibility = #protected))");
			}
		}
	}
	
	/* 4.5.2.13 Constraint */  
	
	if (Model.getFacade().isAConstraint(subject)) {
		if (type.equals(".")) {
			if (feature.equals("body")) {
				return Model.getFacade().getBody(subject);
			}
			if (feature.equals("constrainedElement")) {
				// TODO check this
				return Model.getFacade().getConstrainedElements(subject);
			}
			
		}
	}        
	
	/* 4.5.2.14 Dependency */  
	
	if (Model.getFacade().isADependency(subject)) {
		if (type.equals(".")) {
			if (feature.equals("client")) {
				return new HashSet<Object>(Model.getFacade()
				.getClients(subject));
			}
			if (feature.equals("supplier")) {
				return new HashSet<Object>(Model.getFacade()
				.getSuppliers(subject));
			}
		}
	}        
	
	// TODO ElementOwnership is not in ModelSubsys!!
	
	/* 4.5.2.18 ElementOwnership */          
	
	if (Model.getFacade().isAElementResidence(subject)) {
		if (type.equals(".")) {
			if (feature.equals("visibility")) {
				return Model.getFacade().getVisibility(subject);
			}
		}
	}
	
	/* 4.5.2.19 Enumeration */          
	
	if (Model.getFacade().isAEnumeration(subject)) {
		if (type.equals(".")) {
			if (feature.equals("literal")) {
				return Model.getFacade().getEnumerationLiterals(subject);
			}
		}
	}
	
	/* 4.5.2.20 EnumerationLiteral */          
	
	if (Model.getFacade().isAEnumerationLiteral(subject)) {
		if (type.equals(".")) {
			if (feature.equals("enumeration")) {
				return Model.getFacade().getEnumeration(subject);
			}
		}
	}
	
	/* 4.5.2.21 Feature */          
	
	if (Model.getFacade().isAFeature(subject)) {
		if (type.equals(".")) {
			if (feature.equals("ownerScope")) {
				return Model.getFacade().isStatic(subject);
			}
			if (feature.equals("visibility")) {
				return Model.getFacade().getVisibility(subject);
			}
			if (feature.equals("owner")) {
				return Model.getFacade().getOwner(subject);
			}                
		}
	}        
	
	/* 4.5.2.23 Generalizable Element */          
	
	if (Model.getFacade().isAGeneralizableElement(subject)) {
		if (type.equals(".")) {
			if (feature.equals("isAbstract")) {
				return Model.getFacade().isAbstract(subject);
			}
			if (feature.equals("isLeaf")) {
				return Model.getFacade().isLeaf(subject);
			}
			if (feature.equals("isRoot")) {
				return Model.getFacade().isRoot(subject);
			}
			if (feature.equals("generalization")) {
				return new HashSet<Object>(Model.getFacade()
				.getGeneralizations(subject));
			}
			if (feature.equals("specialization")) {
				return new HashSet<Object>(Model.getFacade()
				.getSpecializations(subject));
			}
			
			// Additional Operation in 4.5.3.20                
			if (feature.equals("parent")) {
				return internalOcl(subject, vt,
				"self.generalization.parent");
			}                
			
			if (feature.equals("allParents")) {
				return internalOcl(subject, vt,
				"self.parent->union(self.parent.allParents)");
			}                
			
		}
	}                
	
	/* 4.5.2.24 Generalization */          
	
	if (Model.getFacade().isAGeneralization(subject)) {
		if (type.equals(".")) {
			if (feature.equals("discriminator")) {
				return Model.getFacade().getDiscriminator(subject);
			}
			if (feature.equals("child")) {
				return Model.getFacade().getSpecific(subject);
			}
			if (feature.equals("parent")) {
				return Model.getFacade().getGeneral(subject);
			}
			if (feature.equals("powertype")) {
				return Model.getFacade().getPowertype(subject);
			}
			if (feature.equals("specialization")) {
				return new HashSet<Object>(Model.getFacade()
				.getSpecializations(subject));
			}                
		}
	}                
	
	/* 4.5.2.26 Method */          
	
	if (Model.getFacade().isAMethod(subject)) {
		if (type.equals(".")) {
			if (feature.equals("body")) {
				return Model.getFacade().getBody(subject);
			}
			if (feature.equals("specification")) {
				return Model.getFacade().getSpecification(subject);
			}
		}
	}
	
	/* 4.5.2.27 ModelElement */          
	
	if (Model.getFacade().isAModelElement(subject)) {
		if (type.equals(".")) {
			if (feature.equals("name")) {
				String name = Model.getFacade().getName(subject);
				if (name == null) {
					// TODO check conformancy to specification
					
					// avoiding null names
					name = "";
				}
				return name;
			}
			
			// TODO asArgument??
			
			if (feature.equals("clientDependency")) {
				return new HashSet<Object>(Model.getFacade()
				.getClientDependencies(subject));
			}                
			if (feature.equals("constraint")) {
				return new HashSet<Object>(Model.getFacade()
				.getConstraints(subject));
			}
			
			// TODO implementationLocation??
			
			if (feature.equals("namespace")) {
				return Model.getFacade().getNamespace(subject);
			}                
			
			// TODO presentation??                
			if (feature.equals("supplierDependency")) {
				return new HashSet<Object>(Model.getFacade()
				.getSupplierDependencies(subject));
			}                
			
			if (feature.equals("templateParameter")) {
				return Model.getFacade().getTemplateParameters(subject);
			}
			
			// As extended by 4.6.2.2
			if (feature.equals("stereotype")) {
				return Model.getFacade().getStereotypes(subject);
			}
			
			if (feature.equals("taggedValue")) {
				return Model.getFacade().getTaggedValuesCollection(subject);
			}
			
			if (feature.equals("constraint")) {
				return Model.getFacade().getConstraints(subject);
			}
			
			// Additional Operations in 4.5.3.25
			if (feature.equals("supplier")) {
				return internalOcl(subject, vt,
				"self.clientDependency.supplier");
			}                                
			
			if (feature.equals("allSuppliers")) {
				return internalOcl(subject, vt,
				"self.supplier->union(self.supplier.allSuppliers)");
			}
			
			if (feature.equals("model")) {
				return internalOcl(subject, vt,
				"self.namespace->"
				+ "union(self.namespace.allSurroundingNamespaces)->"
				+ "select( ns| ns.oclIsKindOf (Model))");
			}
			
			if (feature.equals("isTemplate")) {
				return !Model.getFacade().getTemplateParameters(subject)
				.isEmpty();
			}
			
			if (feature.equals("isInstantiated")) {
				return internalOcl(subject, vt, "self.clientDependency->"
				+ "select(oclIsKindOf(Binding))->notEmpty");
			}
			
			if (feature.equals("templateArgument")) {
				return internalOcl(subject, vt, "self.clientDependency->"
				+ "select(oclIsKindOf(Binding))."
				+ "oclAsType(Binding).argument");
			}
			
		}
	}
	
	/* 4.5.2.28 Namespace */          
	
	if (Model.getFacade().isANamespace(subject)) {
		if (type.equals(".")) {
			if (feature.equals("ownedElement")) {
				return new HashSet<Object>(Model.getFacade()
				.getOwnedElements(subject));
			}
			// Additional Operations in 4.5.3.26
			if (feature.equals("contents")) {
				// TODO investigate typo in spec!!
				return internalOcl(subject, vt, "self.ownedElement->"
				+ "union(self.ownedElement->" 
				+ "select(x|x.oclIsKindOf(Namespace)).contents)");
			}
			
			if (feature.equals("allContents")) {
				return internalOcl(subject, vt, "self.contents");
			}
			
			if (feature.equals("allVisibleElements")) {
				return internalOcl(
				subject,
				vt,
				"self.allContents ->"
				+ "select(e |e.elementOwnership.visibility = #public)");
			}
			
			if (feature.equals("allSurroundingNamespaces")) {
				return internalOcl(subject, vt, "self.namespace->"
				+ "union(self.namespace.allSurroundingNamespaces)");
			}                                               
		}                        
	}
	
	
	/* 4.5.2.29 Node */          
	
	if (Model.getFacade().isANode(subject)) {
		if (type.equals(".")) {
			if (feature.equals("deployedComponent")) {
				return new HashSet<Object>(Model.getFacade()
				.getDeployedComponents(subject));
			}                
		}
	}        
	
	/* 4.5.2.30 Operation */          
	
	if (Model.getFacade().isAOperation(subject)) {
		if (type.equals(".")) {
			if (feature.equals("concurrency")) {
				return Model.getFacade().getConcurrency(subject);
			}
			if (feature.equals("isAbstract")) {
				return Model.getFacade().isAbstract(subject);
			}
			if (feature.equals("isLeaf")) {
				return Model.getFacade().isLeaf(subject);
			}
			if (feature.equals("isRoot")) {
				return Model.getFacade().isRoot(subject);
			}
		}
	}                
	
	/* 4.5.2.31 Parameter */          
	
	if (Model.getFacade().isAParameter(subject)) {
		if (type.equals(".")) {
			if (feature.equals("defaultValue")) {
				return Model.getFacade().getDefaultValue(subject);
			}
			if (feature.equals("kind")) {
				return Model.getFacade().getKind(subject);
			}
		}
	}                
	
	/* 4.5.2.35 ProgrammingLanguageDataType */          
	
	// Gone from UML 2.x, so unsupported here
	//        if (Model.getFacade().isAProgrammingLanguageDataType(subject)) {
		//            if (type.equals(".")) {
			//                if (feature.equals("expression")) {
				//                    return Model.getFacade().getExpression(subject);
				//                }
			//            }
		//        }                
	
	/* 4.5.2.37 StructuralFeature */
	
	if (Model.getFacade().isAStructuralFeature(subject)) {
		if (type.equals(".")) {
			if (feature.equals("changeability")) {
				return Model.getFacade().getChangeability(subject);
			}
			if (feature.equals("multiplicity")) {
				return Model.getFacade().getMultiplicity(subject);
			}
			if (feature.equals("ordering")) {
				return Model.getFacade().getOrdering(subject);
			}
			// TODO: Removed from UML 2.x
			if (feature.equals("targetScope")) {
				return Model.getFacade().getTargetScope(subject);
			}
			if (feature.equals("type")) {
				return Model.getFacade().getType(subject);
			}
		}
	}        
	
	/* 4.5.2.38 TemplateArgument */
	
	if (Model.getFacade().isATemplateArgument(subject)) {
		if (type.equals(".")) {
			if (feature.equals("binding")) {
				return Model.getFacade().getBinding(subject);
			}
			if (feature.equals("modelElement")) {
				return Model.getFacade().getModelElement(subject);
			}
		}
	}        
	
	/* 4.5.2.39 TemplateParameter */
	
	if (Model.getFacade().isATemplateParameter(subject)) {
		if (type.equals(".")) {
			if (feature.equals("defaultElement")) {
				return Model.getFacade().getDefaultElement(subject);
			}
		}
	}                
	
	/* 4.11.3.5 UseCase */
	if (Model.getFacade().isAUseCase(subject)) {
		if (type.equals(".")) {
			if (feature.equals("specificationPath")) {
				/*  The operation specificationPath results in a set containing 
				* all surrounding Namespaces that are not instances of
				*  Package.
				*  specificationPath : Set(Namespace) 
				* specificationPath = self.allSurroundingNamespaces->select(n |
				*    n.oclIsKindOf(Subsystem) or n.oclIsKindOf(Class))
				**/
				return Model.getUseCasesHelper().getSpecificationPath(subject);
			}
			if (feature.equals("allExtensionPoints")) {
				Collection c = Model.getCoreHelper().getAllSupertypes(subject);
				Collection result = new ArrayList(Model.getFacade().getExtensionPoints(subject));
				for (Object uc : c) {
					result.addAll(Model.getFacade().getExtensionPoints(uc));
				}
				return result;
			}
		}
	}
	
	/* 4.5.3.2 AssociationClass */
	
	if (Model.getFacade().isAAssociationClass(subject)) {
		if (type.equals(".")) {
			if (feature.equals("allConnections")) {
				/* The operation allConnections results in the set of all 
				* AssociationEnds of the AssociationClass, including all
				* connections defined by its parent (transitive closure).
				*/
				return internalOcl(
				subject,
				vt,
				"self.connection->union(self.parent->select("
				+ "s | s.oclIsKindOf(Association))->collect("
				+ "a : Association | a.allConnections))->asSet()");
			}                              
		}            
	}
	
	/* 4.6.2.3 Stereotype */          
	
	if (Model.getFacade().isAStereotype(subject)) {
		if (type.equals(".")) {
			if (feature.equals("baseClass")) {
				return new HashSet<Object>(Model.getFacade()
				.getBaseClasses(subject));
			}
			if (feature.equals("extendedElement")) {
				return new HashSet<Object>(Model.getFacade()
				.getExtendedElements(subject));
			}
			if (feature.equals("definedTag")) {
				return new HashSet<Object>(Model.getFacade()
				.getTagDefinitions(subject));
			}
			// stereotypeConstraint ?
		}
	}
	
	/* 4.6.2.4 TagDefinition */          
	
	if (Model.getFacade().isATagDefinition(subject)) {
		if (type.equals(".")) {
			if (feature.equals("multiplicity")) {
				return Model.getFacade().getMultiplicity(subject);
			}
			if (feature.equals("tagType")) {
				return Model.getFacade().getType(subject);
			}
			if (feature.equals("typedValue")) {
				return new HashSet<Object>(Model.getFacade()
				.getTypedValues(subject));
			}
			if (feature.equals("owner")) {
				return Model.getFacade().getOwner(subject);
			}
		}
	}
	
	/* 4.6.2.5 TaggedValue */          
	
	if (Model.getFacade().isATaggedValue(subject)) {
		if (type.equals(".")) {
			if (feature.equals("dataValue")) {
				return Model.getFacade().getDataValue(subject);
			}
			if (feature.equals("type")) {
				return Model.getFacade().getType(subject);
			}
			if (feature.equals("referenceValue")) {
				return new HashSet<Object>(Model.getFacade()
				.getReferenceValue(subject));
			}
		}
	}
	return null;
}
\end{lstlisting}
\end{mdframed}

Method \textit{initialize} in class \textsc{RE} of \textsc{jEdit} project.

\begin{mdframed}
\begin{lstlisting}
// The meat of construction
protected void initialize(Object patternObj, int cflags, RESyntax syntax, int myIndex, int nextSub) throws REException {
	char[] pattern;
	if (patternObj instanceof String) {
		pattern = ((String) patternObj).toCharArray();
	} else if (patternObj instanceof char[]) {
		pattern = (char[]) patternObj;
	} else if (patternObj instanceof StringBuffer) {
		pattern = new char [((StringBuffer) patternObj).length()];
		((StringBuffer) patternObj).getChars(0,pattern.length,pattern,0);
	} else {
		pattern = patternObj.toString().toCharArray();
	}
	
	int pLength = pattern.length;
	
	numSubs = 0; // Number of subexpressions in this token.
	Vector branches = null;
	
	// linked list of tokens (sort of -- some closed loops can exist)
	firstToken = lastToken = null;
	
	// Precalculate these so we don't pay for the math every time we
	// need to access them.
	boolean insens = ((cflags & REG_ICASE) > 0);
	
	// Parse pattern into tokens.  Does anyone know if it's more efficient
	// to use char[] than a String.charAt()?  I'm assuming so.
	
	// index tracks the position in the char array
	int index = 0;
	
	// this will be the current parse character (pattern[index])
	CharUnit unit = new CharUnit();
	
	// This is used for {x,y} calculations
	IntPair minMax = new IntPair();
	
	// Buffer a token so we can create a TokenRepeated, etc.
	REToken currentToken = null;
	char ch;
	
	while (index < pLength) {
		// read the next character unit (including backslash escapes)
		index = getCharUnit(pattern,index,unit);
		
		// ALTERNATION OPERATOR
		//  \| or | (if RE_NO_BK_VBAR) or newline (if RE_NEWLINE_ALT)
		//  not available if RE_LIMITED_OPS is set
		
		// TODO: the '\n' literal here should be a test against REToken.newline,
		// which unfortunately may be more than a single character.
		if ( ( (unit.ch == '|' && (syntax.get(RESyntax.RE_NO_BK_VBAR) ^ unit.bk))
		|| (syntax.get(RESyntax.RE_NEWLINE_ALT) && (unit.ch == '\n') && !unit.bk) )
		&& !syntax.get(RESyntax.RE_LIMITED_OPS)) {
			// make everything up to here be a branch. create vector if nec.
			addToken(currentToken);
			RE theBranch = new RE(firstToken, lastToken, numSubs, subIndex, minimumLength);
			minimumLength = 0;
			if (branches == null) {
				branches = new Vector();
			}
			branches.addElement(theBranch);
			firstToken = lastToken = currentToken = null;
		}
		
		// INTERVAL OPERATOR:
		//  {x} | {x,} | {x,y}  (RE_INTERVALS && RE_NO_BK_BRACES)
		//  \{x\} | \{x,\} | \{x,y\} (RE_INTERVALS && !RE_NO_BK_BRACES)
		//
		// OPEN QUESTION: 
		//  what is proper interpretation of '{' at start of string?
			
			else if ((unit.ch == '{') && syntax.get(RESyntax.RE_INTERVALS) && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk)) {
					int newIndex = getMinMax(pattern,index,minMax,syntax);
					if (newIndex > index) {
						if (minMax.first > minMax.second)
						throw new REException(getLocalizedMessage("interval.order"),
						REException.REG_BADRPT,newIndex);
						if (currentToken == null)
						throw new REException(getLocalizedMessage("repeat.no.token"),
						REException.REG_BADRPT,newIndex);
						if (currentToken instanceof RETokenRepeated) 
						throw new REException(getLocalizedMessage("repeat.chained"),
						REException.REG_BADRPT,newIndex);
						if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
						throw new REException(getLocalizedMessage("repeat.assertion"),
						REException.REG_BADRPT,newIndex);
						if ((currentToken.getMinimumLength() == 0) && (minMax.second == Integer.MAX_VALUE))
						throw new REException(getLocalizedMessage("repeat.empty.token"),
						REException.REG_BADRPT,newIndex);
						index = newIndex;
						currentToken = setRepeated(currentToken,minMax.first,minMax.second,index); 
					}
					else {
						addToken(currentToken);
						currentToken = new RETokenChar(subIndex,unit.ch,insens);
					} 
				}
				
				// LIST OPERATOR:
				//  [...] | [^...]
				
				else if ((unit.ch == '[') && !unit.bk) {
					Vector options = new Vector();
					boolean negative = false;
					char lastChar = 0;
					if (index == pLength) throw new REException(getLocalizedMessage("unmatched.bracket"),
					REException.REG_EBRACK,index);
					
					// Check for initial caret, negation
					if ((ch = pattern[index]) == '^') {
						negative = true;
						if (++index == pLength) throw new REException(getLocalizedMessage("class.no.end"),
						REException.REG_EBRACK,index);
						ch = pattern[index];
					}
					
					// Check for leading right bracket literal
					if (ch == ']') {
						lastChar = ch;
						if (++index == pLength) throw new REException(getLocalizedMessage("class.no.end"),
						REException.REG_EBRACK,index);
					}
					
					while ((ch = pattern[index++]) != ']') {
						if ((ch == '-') && (lastChar != 0)) {
							if (index == pLength) throw new REException(getLocalizedMessage("class.no.end"),
							REException.REG_EBRACK,index);
							if ((ch = pattern[index]) == ']') {
								options.addElement(new RETokenChar(subIndex,lastChar,insens));
								lastChar = '-';
							} else {
								options.addElement(new RETokenRange(subIndex,lastChar,ch,insens));
								lastChar = 0;
								index++;
							}
						} else if ((ch == '\\') && syntax.get(RESyntax.RE_BACKSLASH_ESCAPE_IN_LISTS)) {
							if (index == pLength) throw new REException(getLocalizedMessage("class.no.end"),
							REException.REG_EBRACK,index);
							int posixID = -1;
							boolean negate = false;
							char asciiEsc = 0;
							if (("dswDSW".indexOf(pattern[index]) != -1) && syntax.get(RESyntax.RE_CHAR_CLASS_ESC_IN_LISTS)) {
								switch (pattern[index]) {
									case 'D':
									negate = true;
									case 'd':
									posixID = RETokenPOSIX.DIGIT;
									break;
									case 'S':
									negate = true;
									case 's':
									posixID = RETokenPOSIX.SPACE;
									break;
									case 'W':
									negate = true;
									case 'w':
									posixID = RETokenPOSIX.ALNUM;
									break;
								}
							}
							else if ("nrt".indexOf(pattern[index]) != -1) {
								switch (pattern[index]) {
									case 'n':
									asciiEsc = '\n';
									break;
									case 't':
									asciiEsc = '\t';
									break;
									case 'r':
									asciiEsc = '\r';
									break;
								}
							}
							if (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));
							
							if (posixID != -1) {
								options.addElement(new RETokenPOSIX(subIndex,posixID,insens,negate));
							} else if (asciiEsc != 0) {
								lastChar = asciiEsc;
							} else {
								lastChar = pattern[index];
							}
							++index;
						} else if ((ch == '[') && (syntax.get(RESyntax.RE_CHAR_CLASSES)) && (index < pLength) && (pattern[index] == ':')) {
							StringBuffer posixSet = new StringBuffer();
							index = getPosixSet(pattern,index+1,posixSet);
							int posixId = RETokenPOSIX.intValue(posixSet.toString());
							if (posixId != -1)
							options.addElement(new RETokenPOSIX(subIndex,posixId,insens,false));
						} else {
							if (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));
							lastChar = ch;
						}
						if (index == pLength) throw new REException(getLocalizedMessage("class.no.end"),
						REException.REG_EBRACK,index);
					} // while in list
					// Out of list, index is one past ']'
					
					if (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));
					
					// Create a new RETokenOneOf
					addToken(currentToken);
					options.trimToSize();
					currentToken = new RETokenOneOf(subIndex,options,negative);
				}
				
				// SUBEXPRESSIONS
				//  (...) | \(...\) depending on RE_NO_BK_PARENS
				
				else if ((unit.ch == '(') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk)) {
					boolean pure = false;
					boolean comment = false;
					boolean lookAhead = false;
					boolean negativelh = false;
					if ((index+1 < pLength) && (pattern[index] == '?')) {
						switch (pattern[index+1]) {
							case '!':
							if (syntax.get(RESyntax.RE_LOOKAHEAD)) {
								pure = true;
								negativelh = true;
								lookAhead = true;
								index += 2;
							}
							break;
							case '=':
							if (syntax.get(RESyntax.RE_LOOKAHEAD)) {
								pure = true;
								lookAhead = true;
								index += 2;
							}
							break;
							case ':':
							if (syntax.get(RESyntax.RE_PURE_GROUPING)) {
								pure = true;
								index += 2;
							}
							break;
							case '#':
							if (syntax.get(RESyntax.RE_COMMENTS)) {
								comment = true;
							}
							break;
							default:
							throw new REException(getLocalizedMessage("repeat.no.token"), REException.REG_BADRPT, index);
						}
					}
					
					if (index >= pLength) {
						throw new REException(getLocalizedMessage("unmatched.paren"), REException.REG_ESUBREG,index);
					}
					
					// find end of subexpression
					int endIndex = index;
					int nextIndex = index;
					int nested = 0;
					
					while ( ((nextIndex = getCharUnit(pattern,endIndex,unit)) > 0)
					&& !(nested == 0 && (unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk)) )
					if ((endIndex = nextIndex) >= pLength)
					throw new REException(getLocalizedMessage("subexpr.no.end"),
					REException.REG_ESUBREG,nextIndex);
					else if (unit.ch == '(' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))
					nested++;
					else if (unit.ch == ')' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))
					nested--;
					
					// endIndex is now position at a ')','\)' 
					// nextIndex is end of string or position after ')' or '\)'
					
					if (comment) index = nextIndex;
					else { // not a comment
						// create RE subexpression as token.
						addToken(currentToken);
						if (!pure) {
							numSubs++;
						}
						
						int useIndex = (pure || lookAhead) ? 0 : nextSub + numSubs;
						currentToken = new RE(String.valueOf(pattern,index,endIndex-index).toCharArray()
						,cflags,syntax,useIndex,nextSub + numSubs);
						numSubs += ((RE) currentToken).getNumSubs();
						
						if (lookAhead) {
							currentToken = new RETokenLookAhead(currentToken,negativelh);
						}
						
						index = nextIndex;
					} // not a comment
				} // subexpression
				
				// UNMATCHED RIGHT PAREN
				// ) or \) throw exception if
				// !syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD)
				else if (!syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD) && ((unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))) {
					throw new REException(getLocalizedMessage("unmatched.paren"),
					REException.REG_EPAREN,index);
				}
				
				// START OF LINE OPERATOR
				//  ^
				
				else if ((unit.ch == '^') && !unit.bk) {
					addToken(currentToken);
					currentToken = null;
					addToken(new RETokenStart(subIndex,((cflags & REG_MULTILINE) > 0) ? syntax.getLineSeparator() : null));
				}
				
				// END OF LINE OPERATOR
				//  $
				
				else if ((unit.ch == '$') && !unit.bk) {
					addToken(currentToken);
					currentToken = null;
					addToken(new RETokenEnd(subIndex,((cflags & REG_MULTILINE) > 0) ? syntax.getLineSeparator() : null));
				}
				
				// MATCH-ANY-CHARACTER OPERATOR (except possibly newline and null)
				//  .
				
				else if ((unit.ch == '.') && !unit.bk) {
					addToken(currentToken);
					currentToken = new RETokenAny(subIndex,syntax.get(RESyntax.RE_DOT_NEWLINE) || ((cflags & REG_DOT_NEWLINE) > 0),syntax.get(RESyntax.RE_DOT_NOT_NULL));
				}
				
				// ZERO-OR-MORE REPEAT OPERATOR
				//  *
				
				else if ((unit.ch == '*') && !unit.bk) {
					if (currentToken == null)
					throw new REException(getLocalizedMessage("repeat.no.token"),
					REException.REG_BADRPT,index);
					if (currentToken instanceof RETokenRepeated)
					throw new REException(getLocalizedMessage("repeat.chained"),
					REException.REG_BADRPT,index);
					if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
					throw new REException(getLocalizedMessage("repeat.assertion"),
					REException.REG_BADRPT,index);
					if (currentToken.getMinimumLength() == 0)
					throw new REException(getLocalizedMessage("repeat.empty.token"),
					REException.REG_BADRPT,index);
					currentToken = setRepeated(currentToken,0,Integer.MAX_VALUE,index);
				}
				
				// ONE-OR-MORE REPEAT OPERATOR
				//  + | \+ depending on RE_BK_PLUS_QM
				//  not available if RE_LIMITED_OPS is set
				
				else if ((unit.ch == '+') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ unit.bk)) {
					if (currentToken == null)
					throw new REException(getLocalizedMessage("repeat.no.token"),
					REException.REG_BADRPT,index);
					if (currentToken instanceof RETokenRepeated)
					throw new REException(getLocalizedMessage("repeat.chained"),
					REException.REG_BADRPT,index);
					if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
					throw new REException(getLocalizedMessage("repeat.assertion"),
					REException.REG_BADRPT,index);
					if (currentToken.getMinimumLength() == 0)
					throw new REException(getLocalizedMessage("repeat.empty.token"),
					REException.REG_BADRPT,index);
					currentToken = setRepeated(currentToken,1,Integer.MAX_VALUE,index);
				}
				
				// ZERO-OR-ONE REPEAT OPERATOR / STINGY MATCHING OPERATOR
				//  ? | \? depending on RE_BK_PLUS_QM
				//  not available if RE_LIMITED_OPS is set
				//  stingy matching if RE_STINGY_OPS is set and it follows a quantifier
				
				else if ((unit.ch == '?') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ unit.bk)) {
					if (currentToken == null) throw new REException(getLocalizedMessage("repeat.no.token"),
					REException.REG_BADRPT,index);
					
					// Check for stingy matching on RETokenRepeated
					if (currentToken instanceof RETokenRepeated) {
						if (syntax.get(RESyntax.RE_STINGY_OPS) && !((RETokenRepeated)currentToken).isStingy())
						((RETokenRepeated)currentToken).makeStingy();
						else
						throw new REException(getLocalizedMessage("repeat.chained"),
						REException.REG_BADRPT,index);
					}
					else if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
					throw new REException(getLocalizedMessage("repeat.assertion"),
					REException.REG_BADRPT,index);
					else
					currentToken = setRepeated(currentToken,0,1,index);
				}
				
				// BACKREFERENCE OPERATOR
				//  \1 \2 ... \9
				// not available if RE_NO_BK_REFS is set
				
				else if (unit.bk && Character.isDigit(unit.ch) && !syntax.get(RESyntax.RE_NO_BK_REFS)) {
					addToken(currentToken);
					currentToken = new RETokenBackRef(subIndex,Character.digit(unit.ch,10),insens);
				}
				
				// START OF STRING OPERATOR
				//  \A if RE_STRING_ANCHORS is set
				
				else if (unit.bk && (unit.ch == 'A') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
					addToken(currentToken);
					currentToken = new RETokenStart(subIndex,null);
				}
				
				// WORD BREAK OPERATOR
				//  \b if ????
				
				else if (unit.bk && (unit.ch == 'b') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
					addToken(currentToken);
					currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN | RETokenWordBoundary.END, false);
				} 
				
				// WORD BEGIN OPERATOR 
				//  \< if ????
				else if (unit.bk && (unit.ch == '<')) {
					addToken(currentToken);
					currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN, false);
				} 
				
				// WORD END OPERATOR 
				//  \> if ????
				else if (unit.bk && (unit.ch == '>')) {
					addToken(currentToken);
					currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.END, false);
				} 
				
				// NON-WORD BREAK OPERATOR
				// \B if ????
				
				else if (unit.bk && (unit.ch == 'B') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
					addToken(currentToken);
					currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN | RETokenWordBoundary.END, true);
				} 
				
				
				// DIGIT OPERATOR
				//  \d if RE_CHAR_CLASS_ESCAPES is set
				
				else if (unit.bk && (unit.ch == 'd') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
					addToken(currentToken);
					currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.DIGIT,insens,false);
				}
				
				// NON-DIGIT OPERATOR
				//  \D
				
				else if (unit.bk && (unit.ch == 'D') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
					addToken(currentToken);
					currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.DIGIT,insens,true);
				}
				
				// NEWLINE ESCAPE
				//  \n
				
				else if (unit.bk && (unit.ch == 'n')) {
					addToken(currentToken);
					currentToken = new RETokenChar(subIndex,'\n',false);
				}
				
				// RETURN ESCAPE
				//  \r
				
				else if (unit.bk && (unit.ch == 'r')) {
					addToken(currentToken);
					currentToken = new RETokenChar(subIndex,'\r',false);
				}
				
				// WHITESPACE OPERATOR
				//  \s if RE_CHAR_CLASS_ESCAPES is set
				
				else if (unit.bk && (unit.ch == 's') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
					addToken(currentToken);
					currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.SPACE,insens,false);
				}
				
				// NON-WHITESPACE OPERATOR
				//  \S
				
				else if (unit.bk && (unit.ch == 'S') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
					addToken(currentToken);
					currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.SPACE,insens,true);
				}
				
				// TAB ESCAPE
				//  \t
				
				else if (unit.bk && (unit.ch == 't')) {
					addToken(currentToken);
					currentToken = new RETokenChar(subIndex,'\t',false);
				}
				
				// ALPHANUMERIC OPERATOR
				//  \w
				
				else if (unit.bk && (unit.ch == 'w') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
					addToken(currentToken);
					currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.ALNUM,insens,false);
				}
				
				// NON-ALPHANUMERIC OPERATOR
				//  \W
				
				else if (unit.bk && (unit.ch == 'W') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
					addToken(currentToken);
					currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.ALNUM,insens,true);
				}
				
				// END OF STRING OPERATOR
				//  \Z
				
				else if (unit.bk && (unit.ch == 'Z') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
					addToken(currentToken);
					currentToken = new RETokenEnd(subIndex,null);
				}
				
				// NON-SPECIAL CHARACTER (or escape to make literal)
				//  c | \* for example
				
				else {  // not a special character
					addToken(currentToken);
					currentToken = new RETokenChar(subIndex,unit.ch,insens);
				} 
			} // end while
			
			// Add final buffered token and an EndSub marker
			addToken(currentToken);
			
			if (branches != null) {
				branches.addElement(new RE(firstToken,lastToken,numSubs,subIndex,minimumLength));
				branches.trimToSize(); // compact the Vector
				minimumLength = 0;
				firstToken = lastToken = null;
				addToken(new RETokenOneOf(subIndex,branches,false));
			} 
			else addToken(new RETokenEndSub(subIndex));
			
		}
\end{lstlisting}
\end{mdframed}
